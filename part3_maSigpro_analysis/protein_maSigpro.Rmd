---
title: "Protein Time Course, Enriched"
author: "A2IDEA"
date: "8/17/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Read protein data


```{r, message=F, warning=F, error=F}
suppressMessages(library(dplyr))
options(dplyr.summarise.inform = FALSE) ## stop summarize warning in dplyr
suppressMessages(library(ggplot2))
suppressMessages(library(pheatmap))
suppressMessages(library(limma)) ## for batch correction
suppressMessages(library(maSigPro)) ## package we are using for differential expression
suppressMessages(library(ggpubr))
rm(list=ls());  #source("~/.Rprofile");

setwd("~/Documents/A2IDEAS/UPMC/SOW_2021-7-03-004/PhosphoTimeCourse") # location dependent


rawd <- read.delim("rawd/20210811_STRaxon_full_proteome.txt", as.is=T)

## final output file name
outF <-  "out/20210811_STRaxon_full_proteome.timeCourse.tsv"
out_clusters = gsub(".tsv", ".fullProteome_clusters.pdf", outF)

## you need to rearrange the columns
ms2 <- dplyr::select(rawd, Protein, starts_with("plex"))
colnames(ms2)[1] <- "prots"

```


#### Keep only complete cases
```{r}
tmp <- as.matrix(ms2[,-1])
j <- complete.cases(tmp)

ms2 <- ms2[j,]
rm(tmp, j)
```

### PCA plot

You need this data.frame to evaluate the possible sources of batch effect
```{r}

pheno <- data.frame(lab=colnames(ms2)[-1], 
				  plex=0, state=NA, rep=0,
				  stringsAsFactors=F, 
				  row.names=colnames(ms2)[-1])

pheno$state <- gsub("plex\\d+\\.(.+)\\d+$", "\\1", pheno$lab)
pheno$plex <- as.integer(gsub("plex(\\d+)\\..*", "\\1", pheno$lab))
pheno$rep <- as.integer(gsub("plex\\d+\\.\\w+(\\d+)$", "\\1", pheno$lab))
pheno <- pheno[,-1]

pheno$state <- factor(pheno$state, levels=c("neonate", "earlypostnatal", "preweanling", "adult"))
```



```{r}

mat <- as.matrix(ms2[,-1])
rownames(mat) <- ms2[,1]

df_pca <- prcomp( t(mat), scale=T)

m <- data.frame(PC1=df_pca$x[,1], PC2=df_pca$x[,2], stringsAsFactors=F)

m <- cbind(m, pheno) 
m$plex <- as.factor(m$plex)
m$rep <- as.factor(m$rep)

x <- summary(df_pca)$importance
pc1 <- round((x[2,1] * 100), 2)
PC1_pct <- paste0("PC1 (", pc1, "%)")
pc2 <- round((x[2,2] * 100), 2)
PC2_pct <- paste0("PC2 (", pc2, "%)")
rm(x, pc1, pc2, df_pca)


## constant plotting variables to be used for all plots
theme_obj <-  theme(plot.title = element_text(size = 24, face = "bold"), 
        axis.text = element_text(size = 8), 
        legend.position = "right", 
        legend.title = element_text(face = "bold", size = 10), 
        legend.text = element_text(size = 8))


#======================== make 3 PC plots =================================
p1 <- ggplot(m) +
	geom_point(aes(x=PC1, y=PC2, color=plex), alpha = 0.75, size = 3) + 
	ggtitle("Plex") + 
	xlab(PC1_pct) + ylab(PC2_pct) +
	theme_bw() + theme_obj
 

p2 <- ggplot(m) +
	geom_point(aes(x=PC1, y=PC2, color=state), alpha=0.75, size=3) + 
	ggtitle("State") + 
	xlab(PC1_pct) + ylab(PC2_pct) +
	theme_bw() + theme_obj

p3 <- ggplot(m) +
	geom_point(aes(x=PC1, y=PC2, color=rep), alpha=0.75, size=3) + 
	ggtitle("Replicate") + 
	xlab(PC1_pct) + ylab(PC2_pct) +
	theme_bw() + theme_obj



p <- cowplot::plot_grid(p1, p2, p3, nrow=1, ncol=3)
 ggsave(plot = p, filename = "figures/full_protein_timeCourse_PCAall.pdf", units = "in", height = 7, width = 11)

rm(p1, p2, p3, mat, m, PC1_pct, PC2_pct, theme_obj, p)

```





#### Create the design matrix
```{r}
## maSigPro code starts here

## time points:
## "neonate"=1, "earlypostnatal"=2, "preweanling"=3, "adult"=4

d <- select(pheno, rep, plex)
d$Time <- as.numeric(pheno$state)
d$Neonate=0
d$Earlypostnatal=0
d$Preweanling=0
d$Adult=0

## You need to annotate the comparison columns
d$Neonate[ grep("neonate", rownames(d)) ] <- 1
d$Earlypostnatal[ grep("early", rownames(d)) ] <- 1
d$Preweanling[ grep("pre", rownames(d)) ] <- 1
d$Adult[ grep("adult", rownames(d)) ] <- 1

d <- select(d, -plex)

design <- make.design.matrix(edesign=d, 
							 degree=1,
							 time.col=2, ## column for time
							 repl.col=1, ## column for replicates
							 group.cols=c(3,4,5,6))

rm(d)
```


#### Run regression model
```{r, message=F, warning=F, error=F}

d <- as.matrix(ms2[,-1])
rownames(d) <-ms2[,1]


## Perform regression fit for each protein
fit <- p.vector(data=d, 
				design=design, 
				min.obs=1, 
				counts=F, 
				Q = 0.99, # to print out different genes with significance 
				family=gaussian())


tstep <- T.fit(fit, 
			   step.method = "backward", 
			   min.obs=1, 
			   alfa = 0.05, 
			   family=gaussian())

```


```{r}
## Get out all proteins that are significant
## 
## 

map <- select(rawd, Protein, Gene.Symbol)

sigs <- get.siggenes(tstep, rsq = 0, vars = "all")

suma2Venn(sigs$summary)

sigs_all <- see.genes(sigs$sig.genes, show.fit = T, dis =design$dis,
cluster.method="hclust" ,cluster.data = 1, k = 8)

tmp <- as.data.frame(sigs_all$cut) %>%
  tibble::rownames_to_column("Protein")  %>%
  dplyr::rename(cluster = "sigs_all$cut") %>%
  left_join(map, by = "Protein")

  
write.table(tmp, file= "out/20210811_STRaxon_full_proteome.timeCourse_8clusterMembership_maSigPro_ALL.tsv", sep="\t", row.names=F)


see.genes(sigs$sig.genes, show.fit = T, dis =design$dis,
cluster.method="hclust" ,cluster.data = 1, k = 8)


```


### Optimal number of clusters K
Before you can cluster the proteins/peptides you need to identify the optimal number of clusters to use. This code uses the ‘elbow method’.

```{r}
set.seed(1234)
k.max <- 25

wss <- sapply(1:k.max, function(k) { kmeans(d, k, nstart=50, iter.max=15)$tot.withinss })

plot(1:k.max, y=wss, type="b", pch=19, xaxt="n", xlab="# Clusters K", ylab="Total within-cluster sum of squares")
axis(1, at=seq(1,k.max), las=1)

rm(k.max, wss)
```
Looks like `K=4` is ideal

```{r}
getClusterMembership <- function(group, K=8) {
    ## group: one of the values from names(sigs$sig.genes)
    ## K: number of clusters (default is 8 but this is arbitrary)
   
	pdf(file="/dev/null")
    x <- see.genes(sigs$sig.genes[[group]], 
          time.col=2,
          repl.col=1,
          group.cols=c(3:6),
          show.fit=F, 
          k=K,
          dis=design$dis)
    dev.off()
    
    clusterMembers <- data.frame(prot=names(x$cut), 
                                 cluster=x$cut, 
                                 stringsAsFactors=F,
                                 row.names=NULL)
    clusterMembers <- arrange(clusterMembers, cluster, prot)    
    return(clusterMembers)
}

```


Function to plot the proteins in each cluster
```{r, warning=F, message=FALSE}
getClusterPlots <- function(memb) {
    ## memb : membership data.frame from getClusterMembership() output
    
    ## desired factor levels for plots:
    fctLvl <- colnames(ms2)[-1]
    
    PL = list() ## will hold plots
    for(k in sort(unique(memb$cluster))) {
        
        tmp <- filter(memb, cluster == k) %>%
            rename("prots"="prot") %>%
            inner_join(y=ms2, by="prots") %>% 
        	select(-cluster) %>%
            reshape2::melt(id.var="prots") %>%
            arrange(prots, variable)
        
        N <- length(unique(tmp$prots))
        
        tmp$variable <- factor(as.character(tmp$variable), levels=fctLvl)
        tmp$prots <- as.factor(tmp$prots)
        px <- ggplot(tmp) + 
            geom_line(aes(x=variable, y=value, group=prots, color=prots), size=0.5) +
            ggtitle(paste0("Cluster ", k, ", N=", N)) + 
            theme_bw() + 
            theme(legend.position="none", 
                  axis.text.x=element_text(angle=45, hjust=1, size=8),
                  axis.title.x=element_blank())
        
        PL[[k]] = px
    }
    return(PL)
}
```


Now plot the clusters per group

```{r, warning=F, message=FALSE}
num_clusters = 8 ## determined earlier by elbow plot
tags <- names(sigs$sig.genes)
df <- data.frame(comparison=tags, N=0, stringsAsFactors=F)

cluster_plots = list() 
cluster_members = data.frame() ## holds proteins and their cluster assignments
for(i in 1:nrow(df)) {
    df$N[i] <- sigs$sig.genes[[ i ]]$g ## number of features in this group
    x <- getClusterMembership(df$comparison[i], K=num_clusters)
    
    PL <- getClusterPlots(x)
    
    tmp <-  x %>% mutate(group=df$comparison[i])
    cluster_members <- rbind(cluster_members, tmp)
    rm(tmp)
    
    title <- cowplot::ggdraw() + cowplot::draw_label(df$comparison[i])
    p1 <- cowplot::plot_grid(plotlist=PL, ncol=2, nrow=2)
    p2 <- cowplot::plot_grid(title, p1, ncol=1, rel_heights=c(0.1,1))
    
    cluster_plots[[i]] = p2
    rm(x, PL, p1, p2, title)
}

pdf(file=out_clusters, width=10, height=8)
for(i in 1:length(cluster_plots)) { plot(cluster_plots[[i]]); }
dev.off()



```

## Record clusters

```{r}
res <- cbind(padjust=fit$p.adjusted[ fit$p.adjusted < 1 ], fit$SELEC)
res <- data.frame(prot=rownames(res), 
				  res,
				  row.names=NULL,
				  stringsAsFactors=F)


map <- select(rawd, Protein, Gene.Symbol)
res <- inner_join(x=map, y=res, by=c("Protein"="prot"))
res1 <- right_join(x=tmp, y=res,by=c("Protein", "Gene.Symbol"))
#res <- arrange(res, group, cluster)


write.table(res, file=outF, sep="\t", row.names=F)
write.table(res1, file= "out/20210811_STRaxon_full_proteome.timeCourse_ALL.tsv", sep="\t", row.names=F)

rm(d)
```




## QC results

This function will plot the data points for a given row of `res` to interpret the results.
```{r}

getPlot <- function(inDF=res, i) {
	## inDF = res dataFrame from previous section
	## i = row index you want to plot
	
	tmp_pheno <- data.frame(variable=rownames(pheno), pheno)
	
	m <- select(inDF, -cluster, -group) %>%
		reshape2::melt(id.vars=c("prot", "Gene.Symbol", "padjust")) %>%
		inner_join(y=tmp_pheno, by="variable") %>%
		select(-variable)
	
	m <- filter(m, prot == res$prot[i])
	m$rep <- as.factor(m$rep)

	
	ret <- ggplot(m) + 
		geom_boxplot(aes(x=state, y=value, fill=state), outlier.shape=NA, alpha=0.75, color="black") + 
		geom_point(aes(x=state, y=value), position=position_jitter(width=0.2), size=2) +
		ggtitle(paste0(m$prot[1],": ", m$Gene.Symbol[1])) + 
		theme_bw() + 
		theme(axis.title.x=element_blank(), legend.position="none")
	
	return(ret)
}

```

Clustering heatmap; just significant proteins

```{r}
library(tidyverse)

df <- res %>%
  dplyr::filter(padjust < 0.05) %>%
  select(Gene.Symbol, everything()) %>%
  group_by(Gene.Symbol) %>%
  arrange(padjust) %>%
  slice(1L) %>%
  select(-Protein, -padjust) %>%
  ungroup() %>%
  dplyr::filter(complete.cases(Gene.Symbol)) %>%
  tibble::column_to_rownames(var="Gene.Symbol") 

df.m <- as.matrix(df)
distance = dist(df.m, method = "euclidean")
cluster = hclust(distance, method = "ward.D2")
p <- heatmap(df.m,
        scale = "row",
        Rowv =  as.dendrogram(cluster), 
       Colv = NA, 
       cexRow = 0.2, 
        cexCol = 0.6, 
       keep.dendro = T
        )
ggsave(plot = p, filename = "figures/heatmap_20210811_STRaxon_full_proteome.timeCours.pdf")

row.clusters <- hclust(dist(df.m))
test <- cutree(row.clusters, k=8)
print.clust <- t(test) %>%
  as.data.frame() 

out <- t(print.clust) %>%
  as.data.frame()
out1 <- tibble::rownames_to_column(out, "GeneSym")  %>%
  dplyr::rename(cluster = V1)

write.table(out1, file= "out/20210811_STRaxon_full_proteome.timeCourse_8clusterMembership_heatmap.tsv", sep="\t", row.names=F)
  
```







